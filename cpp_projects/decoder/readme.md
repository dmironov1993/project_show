# Substitution decoder

Вам задан текст на английском языке, который зашифрован с помощью перестановки алфавита. Для этого берется случайная перестановка
исходного алфавита ('a', 'b', ..., 'z'), после чего каждая буква преобразуется в ей соответствующую, например при перестановке
```
a -> f
b -> t
c -> c
d -> z
...
```

строка 'abcd' будет зашифрована как 'ftcz'. Таким образом ключом шифра является перестановка длиной 26.
Необходимо по заданному зашифрованному тексту восстановить исходный.

Вы можете реализовать любой алгоритм на свой вкус, но для сдачи задачи достаточно простейшего hill-climbing алгоритма. Рассмотрим
некоторую перестановку `P`, пусть это текущий кандидат-ключ. Применим к `P` случайную транспозицию (поменяем 2 символа местами), получив
перестановку `P'`. Если текст при преобразовании `P'` стал <<ближе>> к английскому, чем при `P`, то применим эту транспозицию, иначе
останемся в `P`. Будем повторять описанную процедуру много раз (10000 в этой задаче должно быть достаточно).

Осталось только определить <<близость>> текста к английскому. Для этого можно воспользоваться частотным анализом, описанным здесь
http://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/. Там же вы можете найти файл `english_quadgrams.txt`,
используемый в этом анализе.

Реализуйте 2 функции в `decoder.h`:

* `Map ReadNgrams(cconst std::filesystem::path& path)`, которая считывает файл с квадрограммами, упомянутый выше, и возвращает словарь с
отображением `quadgram -> log probability`. Впрочем, вы можете переопределить тип `Map` на свое усмотрение.
* `std::string Decode(const std::string& text, const Map& dict, const std::filesystem::path& path)` , которая принимает:
    1. зашифрованный текст
    2. словарь, считанный с помощью предыдущей функции
    3. путь до файла `english_letters.txt`

    Функция должна вернуть расшифрованный текст. Функция не должна изменять символы, не являющиеся
буквами. Также необходимо сохранять регистр символов. Например, в примере ранее строка `Ftcz` должна быть дешифрована как `Abcd`.

### Примечания

* Зашифрованные тексты можно найти в `tests`. Те же тексты используются в приватных тестах на сервере.
* Для работы с символами вам могут пригодиться функции из `cctype`, а именно `isalpha`, `islower`, `tolower` и аналогичные.
* Для генерации случайных чисел используйте заголовочный файл `<random>`, а не функцию `rand()`. Подробнее можно прочитать в
[туториале](../docs/random-tutorial.md).
* Описанный выше алгоритм слишком примитивен и может справиться только с длинными текстами (как в тестах), на практике имеет смысл
использовать более продвинутые методы дискретной оптимизации. Если вы все реализовали верно, но простейший алгоритм не сходится, попробуйте подобрать
random seed.
